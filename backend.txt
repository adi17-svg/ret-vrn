routes.py:


from flask import Blueprint, request, jsonify, Response, current_app
import json
import os
import traceback
from datetime import datetime
from collections import defaultdict
import requests
import time
from urllib.parse import quote_plus

from tasks import generate_daily_task, save_completed_task, get_user_tasks
from rewards import (
    get_user_progress,
    save_user_progress,
    update_streak,
    check_streak_rewards,
    check_message_rewards,
)
from spiral_dynamics import (
    detect_intent,
    classify_stage,
    check_evolution,
    generate_reflective_question,
    generate_gamified_prompt,
    client,
    build_mission_feedback_line,
)
from firebase_utils import db, save_conversation_message, get_recent_conversation
from notifications import send_welcome_notification
from tts import stream_tts_from_openai  # OpenAI TTS streamer

bp = Blueprint("main", __name__)  # ‚úÖ yahan __name__ hi use karna hai

AUDIO_FOLDER = "audios"
os.makedirs(AUDIO_FOLDER, exist_ok=True)

# How many last messages to include as context (adjust as needed)
HISTORY_LIMIT = 6

XP_REWARDS = {
    "level_up": 10,
    "daily_streak_3": 15,
    "daily_streak_7": 30,
    "daily_streak_14": 50,
    "daily_streak_30": 100,
    "message_streak": 20,
}

BADGES = {
    "level_up": "üå± Level Up",
    "daily_streak_3": "üî• 3-Day Streak",
    "daily_streak_7": "üåü Weekly Explorer",
    "daily_streak_14": "üåô Fortnight Champion",
    "daily_streak_30": "üåï Monthly Master",
    "message_streak": "üí¨ Chatterbox",
}

# ‚úÖ New mission milestone rewards
MISSION_REWARDS = {
    1: {"xp": 20, "badge": "üéØ First Mission"},
    5: {"xp": 50, "badge": "üèÖ Mission Explorer"},
    10: {"xp": 100, "badge": "üöÄ Mission Master"},
}

# ======================================================
# RESPONSE TYPE DECIDER (Wysa-style logic)
# ======================================================

def decide_response_type(mood: str, intent: str) -> str:
    """
    Decides HOW to respond, not WHAT to say
    """
    if intent == "chat":
        return "listen"

    if mood in ["sad", "anxious", "overwhelmed", "tired", "stressed"]:
        return "validate"

    if mood in ["confused", "stuck", "uncertain"]:
        return "reflect"

    return "act"

# def process_reflection_core(
#     entry: str,
#     user_id: str | None,
#     last_stage: str = "",
#     reply_to: str = "",
# ):
#     """
#     ‚úÖ FINAL CLEAN CORE (FRONTEND-COMPATIBLE)

#     Flow:
#     User input
#       ‚Üí Intent + Emotion + Spiral Stage detect
#       ‚Üí IF stage detected:
#             - Mind Mirror  ‚Üí question
#             - Mission      ‚Üí gamified.gamified_prompt
#       ‚Üí Response type decide
#       ‚Üí Support focus bias
#       ‚Üí Final response
#     """

#     # --------------------------------------------------
#     # 1Ô∏è‚É£ SUPPORT FOCUS (SOFT BIAS)
#     # --------------------------------------------------
#     support_focus = []
#     if user_id:
#         try:
#             doc = db.collection("users").document(user_id).get()
#             if doc.exists:
#                 support_focus = doc.to_dict().get("support_focus", [])
#         except Exception:
#             pass

#     # --------------------------------------------------
#     # 2Ô∏è‚É£ INTENT + EMOTION + SPIRAL STAGE
#     # --------------------------------------------------
#     intent = detect_intent(entry)
#     mood = None
#     stage = None

#     try:
#         result = classify_stage(entry)
#         mood = result.get("mood") or result.get("emotion")
#         stage = result.get("stage")  # üî• THIS decides spiral
#     except Exception:
#         pass

#     # --------------------------------------------------
#     # 3Ô∏è‚É£ RESPONSE TYPE (EVEN FOR CHAT)
#     # --------------------------------------------------
#     response_type = decide_response_type(mood, intent)

#     # --------------------------------------------------
#     # 4Ô∏è‚É£ SPIRAL MODE ON / OFF
#     # --------------------------------------------------
#     spiral_active = bool(stage)

#     # Casual guard
#     if len(entry.split()) < 4:
#         spiral_active = False

#     # --------------------------------------------------
#     # 5Ô∏è‚É£ CONTEXT (PAST CHAT)
#     # --------------------------------------------------
#     context_messages = []
#     if user_id:
#         try:
#             recent = get_recent_conversation(user_id, limit=HISTORY_LIMIT)
#             for m in recent:
#                 if m.get("role") in ("user", "assistant"):
#                     context_messages.append({
#                         "role": m["role"],
#                         "content": m["content"]
#                     })
#         except Exception:
#             pass

#     # --------------------------------------------------
#     # 6Ô∏è‚É£ MIND MIRROR + MISSION (ONLY IF SPIRAL)
#     # --------------------------------------------------
#     question = ""
#     gamified = {}

#     if spiral_active:
#         try:
#             question = generate_reflective_question(entry, reply_to) or ""
#         except Exception:
#             question = ""

#         try:
#             gamified = generate_gamified_prompt(stage, entry) or {}
#         except Exception:
#             gamified = {}

#     # --------------------------------------------------
#     # 7Ô∏è‚É£ SYSTEM PROMPT
#     # --------------------------------------------------
#     system_prompt = (
#         "You are a warm, grounded companion in the RETVRN app.\n\n"
#         f"Response style: {response_type}\n\n"
#         "Rules:\n"
#         "- validate ‚Üí acknowledge feelings\n"
#         "- listen ‚Üí stay present\n"
#         "- reflect ‚Üí mirror insight\n"
#         "- act ‚Üí suggest 1 gentle action\n\n"
#         f"User support focus (soft bias): {', '.join(support_focus) or 'none'}\n"
#         "Never mention it explicitly.\n"
#     )

#     if spiral_active:
#         system_prompt += (
#             "\nIntegrate naturally:\n"
#             f"Mind Mirror: {question}\n"
#             f"Mission: {gamified.get('gamified_prompt', '')}\n"
#         )

#     # --------------------------------------------------
#     # 8Ô∏è‚É£ GPT CALL
#     # --------------------------------------------------
#     messages = [
#         {"role": "system", "content": system_prompt},
#         *context_messages,
#         {"role": "user", "content": entry},
#     ]

#     resp = client.chat.completions.create(
#         model="gpt-4.1",
#         messages=messages,
#         temperature=0.7,
#     )

#     ai_text = resp.choices[0].message.content.strip()

#     # --------------------------------------------------
#     # 9Ô∏è‚É£ SAVE MEMORY
#     # --------------------------------------------------
#     if user_id:
#         try:
#             save_conversation_message(user_id, "user", entry)
#             save_conversation_message(user_id, "assistant", ai_text)
#         except Exception:
#             pass

#     # --------------------------------------------------
#     # üîü RETURN (üî• MATCHES FRONTEND EXACTLY)
#     # --------------------------------------------------
#     if not spiral_active:
#         return {
#             "mode": "chat",
#             "response": ai_text,
#         }

#     return {
#         "mode": "spiral",
#         "response": ai_text,
#         "stage": stage,
#         "question": question,              # üß† Mind Mirror
#         "gamified": gamified,              # üéØ Mission inside
#     }
def process_reflection_core(
    entry: str,
    user_id: str | None,
    last_stage: str = "",
    reply_to: str = "",
):
    """
    FINAL STABLE VERSION

    Returns (for frontend):
    - mode: chat | spiral
    - response: assistant text
    - stage
    - evolution (only if level increased)
    - question (Mind Mirror)
    - gamified (Mission)
    - growth (mission text alias)
    """

    # --------------------------------------------------
    # 1Ô∏è‚É£ SUPPORT FOCUS (soft bias only)
    # --------------------------------------------------
    support_focus = []
    if user_id:
        try:
            doc = db.collection("users").document(user_id).get()
            if doc.exists:
                support_focus = doc.to_dict().get("support_focus", [])
        except Exception:
            pass

    # --------------------------------------------------
    # 2Ô∏è‚É£ INTENT + SPIRAL CLASSIFICATION
    # --------------------------------------------------
    intent = detect_intent(entry)

    mood = None
    stage = None
    confidence = 0.0

    try:
        result = classify_stage(entry)
        mood = result.get("mood")
        stage = result.get("stage")
        confidence = result.get("confidence", 0.0)
    except Exception:
        pass

    # --------------------------------------------------
    # 3Ô∏è‚É£ RESPONSE TYPE (Wysa-style)
    # --------------------------------------------------
    response_type = decide_response_type(mood, intent)

    # --------------------------------------------------
    # 4Ô∏è‚É£ SPIRAL MODE ON / OFF
    # --------------------------------------------------
    spiral_active = bool(stage)

    # very short / casual text ‚Üí no spiral
    if len(entry.split()) < 4:
        spiral_active = False

    # --------------------------------------------------
    # 5Ô∏è‚É£ CONTEXT (PAST CHAT)
    # --------------------------------------------------
    context_messages = []
    if user_id:
        try:
            recent = get_recent_conversation(user_id, limit=HISTORY_LIMIT)
            for m in recent:
                if m.get("role") in ("user", "assistant"):
                    context_messages.append(
                        {"role": m["role"], "content": m["content"]}
                    )
        except Exception:
            pass

    # --------------------------------------------------
    # 6Ô∏è‚É£ MIND MIRROR + MISSION
    # --------------------------------------------------
    question = ""
    gamified = {}

    if spiral_active:
        try:
            question = generate_reflective_question(entry, reply_to) or ""
        except Exception:
            question = ""

        try:
            gamified = generate_gamified_prompt(stage, entry) or {}
        except Exception:
            gamified = {}

    # --------------------------------------------------
    # 7Ô∏è‚É£ EVOLUTION CHECK (LEVEL UP)
    # --------------------------------------------------
    evolution_msg = None
    if spiral_active and last_stage:
        evolution_msg = check_evolution(
            last_stage,
            {
                "stage": stage,
                "confidence": confidence,
            },
        )

    # --------------------------------------------------
    # 8Ô∏è‚É£ SYSTEM PROMPT (LLM = language only)
    # --------------------------------------------------
    system_prompt = (
        "You are a warm, grounded companion in the RETVRN app.\n\n"
        f"Response style: {response_type}\n\n"
        "Rules:\n"
        "- validate ‚Üí acknowledge feelings\n"
        "- listen ‚Üí stay present\n"
        "- reflect ‚Üí mirror insight\n"
        "- act ‚Üí suggest 1 gentle action\n\n"
        f"User support focus (soft bias): {', '.join(support_focus) or 'none'}\n"
        "Never mention it explicitly.\n"
    )

    if spiral_active:
        system_prompt += (
            "\nIntegrate naturally:\n"
            f"Mind Mirror: {question}\n"
            f"Mission: {gamified.get('gamified_prompt', '')}\n"
        )

    # --------------------------------------------------
    # 9Ô∏è‚É£ GPT CALL
    # --------------------------------------------------
    messages = [
        {"role": "system", "content": system_prompt},
        *context_messages,
        {"role": "user", "content": entry},
    ]

    resp = client.chat.completions.create(
        model="gpt-4.1",
        messages=messages,
        temperature=0.7,
    )

    ai_text = resp.choices[0].message.content.strip()

    # --------------------------------------------------
    # üîü SAVE CONVERSATION
    # --------------------------------------------------
    if user_id:
        try:
            save_conversation_message(user_id, "user", entry)
            save_conversation_message(user_id, "assistant", ai_text)
        except Exception:
            pass

    # --------------------------------------------------
    # üîö FINAL RESPONSE (FRONTEND CONTRACT)
    # --------------------------------------------------
    if not spiral_active:
        return {
            "mode": "chat",
            "response": ai_text,
        }

    return {
        "mode": "spiral",
        "response": ai_text,

        # üåÄ Spiral identity
        "stage": stage,

        # üå± Level-up message (optional)
        "evolution": evolution_msg or "",

        # üß† Mind Mirror
        "question": question,

        # üéØ Mission
        "gamified": gamified,
        "growth": gamified.get("gamified_prompt", ""),

        # üèÜ Safe defaults for UI
        "badges_earned": [],
    }


@bp.route('/')
def home():
    return "Backend is running"


@bp.route('/daily_task', methods=['GET'])
def daily_task():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        task = generate_daily_task()
        with open("completed_tasks.json") as f:
            completed = json.load(f)
        user_done = any(
            t for t in completed if t.get("user_id") == user_id and t.get("date") == task.get("date") and t.get("completed")
        )
        task["user_done"] = user_done
        return jsonify(task)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch daily task"}), 500


@bp.route('/complete_task', methods=['POST'])
def complete_task():
    data = request.json
    user_id = data.get("user_id")
    task_id = data.get("task_id")
    if not user_id or not task_id:
        return jsonify({"error": "Missing user_id or task_id"}), 400
    try:
        with open("daily_tasks.json") as f:
            tasks = json.load(f)
        task_to_complete = next((t for t in tasks if str(t.get("timestamp")) == task_id and t.get("user_id") == user_id), None)
        if not task_to_complete:
            return jsonify({"error": "Task not found"}), 404
        task_to_complete["completed"] = True
        task_to_complete["completion_timestamp"] = datetime.utcnow().isoformat()
        with open("daily_tasks.json", "w") as f:
            json.dump(tasks, f, indent=2)
        save_completed_task(user_id, task_to_complete)
        return jsonify({"message": "Task marked completed"})
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to complete task"}), 500


@bp.route('/task_history', methods=['GET'])
def task_history():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        tasks = get_user_tasks(user_id, "completed_tasks.json")
        return jsonify(tasks)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch task history"}), 500


@bp.route('/user_progress', methods=['GET'])
def user_progress():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        progress = get_user_progress(user_id)
        return jsonify(progress)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch user progress"}), 500

@bp.route("/merged", methods=["POST"])
def merged():
    data = request.json
    entry = (data.get("text") or "").strip()

    if not entry:
        return jsonify({"error": "Missing text"}), 400

    result = process_reflection_core(
        entry=entry,
        user_id=data.get("user_id"),
        last_stage=data.get("last_stage", ""),
        reply_to=data.get("reply_to", ""),
    )

    # üîä TTS
    audio_url = f"{request.url_root.rstrip('/')}/speak-stream?text={quote_plus(result['response'])}"

    result["audiourl"] = audio_url
    return jsonify(result)

@bp.route("/reflect_transcription", methods=["POST"])
def reflect_transcription():
    if "audio" not in request.files:
        return jsonify({"error": "Missing audio"}), 400

    user_id = request.form.get("user_id")
    audio_file = request.files["audio"]

    path = f"audios/{int(time.time())}.wav"
    audio_file.save(path)

    with open(path, "rb") as f:
        transcript = client.audio.transcriptions.create(
            model="gpt-4o-transcribe",
            file=f,
        )

    text = (transcript.text or "").strip()

    result = process_reflection_core(
        entry=text,
        user_id=user_id,
    )

    audio_url = f"{request.url_root.rstrip('/')}/speak-stream?text={quote_plus(result['response'])}"

    result["audiourl"] = audio_url
    result["transcription"] = text

    return jsonify(result)

# new endpoint for audio stream
@bp.route("/speak-stream", methods=["GET", "POST"])
def speak_stream():
    """
    Streams OpenAI TTS audio as MP3.
    Koi file save nahi hoti, sirf generator se bytes stream hote hain.
    """
    try:
        if request.method == "GET":
            txt = request.args.get("text", "") or ""
        else:
            body = request.get_json(silent=True) or {}
            txt = body.get("text", "") or ""

        current_app.logger.info("==== SPEAK-STREAM ROUTE CALLED ====")
        preview = txt[:120] + ("..." if len(txt) > 120 else "")
        current_app.logger.info("speak-stream preview=%s len=%d", preview, len(txt))

        if not txt.strip():
            return jsonify({"error": "missing text"}), 400

        # OpenAI TTS generator se stream karo (tts.py se)
        generator = stream_tts_from_openai(txt)

        return Response(generator, mimetype="audio/mpeg", direct_passthrough=True)

    except Exception as e:
        current_app.logger.exception(f"Error in speak-stream endpoint: {e}")
        return jsonify({"error": "Internal server error"}), 500
    
@bp.route('/finalize_stage', methods=['POST'])
def finalize_stage():
    try:
        data = request.json
        speaker_id = data.get("speaker_id")
        speaker_stages = data.get("speaker_stages", {})
        last_stage = data.get("last_stage", "")
        reply_to = data.get("reply_to", "")
        user_id = data.get("user_id")

        if speaker_id not in speaker_stages:
            return jsonify({"error": "Speaker not found"}), 400

        speaker_info = speaker_stages[speaker_id]
        current_stage = speaker_info.get("stage", "Unknown")
        text = speaker_info.get("text", "")
        evolution_msg = check_evolution(last_stage, {"stage": current_stage})

        xp_gain = 0
        badges = []
        if user_id and evolution_msg:
            progress = get_user_progress(user_id)
            progress["xp"] += XP_REWARDS.get("level_up", 10)
            if "level_up" not in progress.get("badges", []):
                progress["badges"].append("level_up")
                badges.append("üå± Level Up")
            save_user_progress(user_id, progress)
            xp_gain = XP_REWARDS.get("level_up", 10)

        # gamified = generate_gamified_prompt(current_stage, text, evolution=bool(evolution_msg))
        gamified = generate_gamified_prompt(current_stage, text, evolution=bool(evolution_msg))
        question = generate_reflective_question(text, reply_to)

        # üîä Finalized stage ke liye TTS text
        tts_parts = []
        if current_stage:
            tts_parts.append(f"Stage {current_stage}.")
        if evolution_msg:
            tts_parts.append(evolution_msg)
        if question:
            tts_parts.append(f"Mind Mirror question: {question}")
        if gamified:
            gq = gamified.get("gamified_question") or ""
            gp = gamified.get("gamified_prompt") or ""
            if gq:
                tts_parts.append(gq)
            if gp:
                tts_parts.append(gp)

        tts_text = " ".join(p for p in tts_parts if p)
        base_url = request.url_root.rstrip("/")
        audio_url = (
            f"{base_url}/speak-stream?text={quote_plus(tts_text)}"
            if tts_text else None
        )
        question = generate_reflective_question(text, reply_to)

        return jsonify({
            "stage": current_stage,
            "question": question,
            "evolution": evolution_msg,
            "gamified": gamified,
            "xp_gain": xp_gain,
            "badges": badges,
            "audiourl": audio_url,
        })
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to finalize stage"}), 500
    
@bp.route("/set_support_focus", methods=["POST"])
def set_support_focus():
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        support_focus = data.get("support_focus")

        if not user_id:
            return jsonify({"error": "Missing user_id"}), 400

        if not support_focus:
            # user skipped ‚Üí do nothing
            return jsonify({"status": "skipped"}), 200

        # Normalize to list
        if isinstance(support_focus, str):
            support_focus = [support_focus]

        # üîπ STORE IN SAME USER DOCUMENT (NO NEW COLLECTION)
        db.collection("users").document(user_id).set(
            {
                "support_focus": support_focus,
                "support_focus_set_at": datetime.utcnow(),
            },
            merge=True
        )

        return jsonify({"status": "saved", "support_focus": support_focus})

    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to store support focus"}), 500


__init__.py:


from flask import Flask
from flask_cors import CORS

from routes import bp
from notifications import bp as notifications_bp


def create_app():
    """
    Application factory function to create and configure the Flask app.
    """
    app = Flask(__name__)
    app.config.from_object("config")

    # Enable CORS
    CORS(app)

    # Register blueprints
    app.register_blueprint(bp)
    app.register_blueprint(notifications_bp)

    # üî• START BOTH MORNING + NIGHT SCHEDULERS
    from scheduling import start_schedulers
    start_schedulers()

    return app


config.py:
import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file

A4F_API_KEY = os.getenv("A4F_API_KEY")
ASSEMBLYAI_API_KEY = os.getenv("ASSEMBLYAI_API_KEY")
NOTIFICATION_TIME = os.getenv("NOTIFICATION_TIME", "09:00")
MORNING_INTENTION_TIME = os.getenv("MORNING_INTENTION_TIME", "07:30")

FIREBASE_CONFIG = {
    "type": os.getenv("FIREBASE_TYPE"),
    "project_id": os.getenv("FIREBASE_PROJECT_ID"),
    "private_key_id": os.getenv("FIREBASE_PRIVATE_KEY_ID"),
    "private_key": os.getenv("FIREBASE_PRIVATE_KEY").replace('\\n', '\n'),
    "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
    "client_id": os.getenv("FIREBASE_CLIENT_ID"),
    "auth_uri": os.getenv("FIREBASE_AUTH_URI"),
    "token_uri": os.getenv("FIREBASE_TOKEN_URI"),
    "auth_provider_x509_cert_url": os.getenv("FIREBASE_AUTH_PROVIDER_CERT_URL"),
    "client_x509_cert_url": os.getenv("FIREBASE_CLIENT_CERT_URL"),
    "universe_domain": os.getenv("FIREBASE_UNIVERSE_DOMAIN", "googleapis.com")
}

firebase_utils.py:

import time
import traceback
import firebase_admin
from firebase_admin import credentials, firestore
from config import FIREBASE_CONFIG

def init_firebase():
    """
    Initialize Firebase app and Firestore client.
    Returns the Firestore client instance or None if initialization fails.
    """
    try:
        # Initialize Firebase app with service account credentials
        cred = credentials.Certificate(FIREBASE_CONFIG)
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
        db = firestore.client()
        return db
    except Exception as e:
        print(f"Firebase initialization failed: {e}")
        return None

# Initialize Firestore client at module load
db = init_firebase()


# ------------------------
# Conversation memory helpers
# ------------------------

def save_conversation_message(user_id: str, role: str, content: str, timestamp: int = None) -> bool:
    """
    Save a single conversation message for a user into Firestore.
    Collection path: conversations/{user_id}/messages/{timestamp_doc}
    role: 'user' | 'assistant' | 'system'
    content: message text
    timestamp: epoch ms, optional (generated if not provided)
    Returns True on success, False on failure.
    """
    try:
        if db is None:
            print("Firestore db not initialized - cannot save message.")
            return False
        if timestamp is None:
            timestamp = int(time.time() * 1000)
        # Use timestamp as document id to keep ordering and avoid duplicates
        doc_ref = db.collection("conversations").document(str(user_id)).collection("messages").document(str(timestamp))
        payload = {
            "role": role,
            "content": content,
            "ts": timestamp
        }
        doc_ref.set(payload)
        return True
    except Exception as e:
        print("Error saving conversation message:", e)
        traceback.print_exc()
        return False


def get_recent_conversation(user_id: str, limit: int = 6):
    """
    Return a list of recent messages for a user ordered oldest->newest.
    Each item is a dict: {"role": "...", "content": "...", "ts": ...}
    If db not initialized or error, returns [].
    """
    try:
        if db is None:
            print("Firestore db not initialized - cannot fetch messages.")
            return []
        coll = db.collection("conversations").document(str(user_id)).collection("messages")
        # Query most recent first, then reverse to get oldest->newest
        docs = coll.order_by("ts", direction=firestore.Query.DESCENDING).limit(limit).stream()
        msgs = []
        for d in docs:
            data = d.to_dict()
            msgs.append({
                "role": data.get("role", "user"),
                "content": data.get("content", ""),
                "ts": data.get("ts", 0)
            })
        msgs.reverse()
        return msgs
    except Exception as e:
        print("Error fetching recent conversation:", e)
        traceback.print_exc()
        return []

notifications.py:

from flask import Blueprint, request, jsonify
from datetime import datetime, timezone
import traceback
from firebase_admin import messaging

from firebase_utils import db

bp = Blueprint("notifications", __name__)

# ============================================================
# üåÖ MORNING INTENTION NOTIFICATION
# ============================================================

def send_morning_intention_notification(fcm_token: str):
    try:
        today = datetime.now(timezone.utc).date().isoformat()

        message = messaging.Message(
            notification=messaging.Notification(
                title="üåÖ A gentle start to your day",
                body="Would you like to set a small intention for today?"
            ),
            data={
                "type": "morning_intention",
                "screen": "intention",
                "date": today
            },
            token=fcm_token,
        )

        return messaging.send(message)

    except Exception as e:
        print(f"‚ùå Error sending morning notification: {e}")
        return None


# ============================================================
# üåô NIGHT REFLECTION NOTIFICATION (ROTATING)
# ============================================================

NIGHT_PROMPTS = [
    {
        "title": "üåô Before you rest",
        "body": "How did today feel for you ‚Äî not good or bad, just honestly?"
    },
    {
        "title": "üåô A quiet moment",
        "body": "Was there one small moment today that stayed with you?"
    },
    {
        "title": "üåô End of the day",
        "body": "Is there anything you‚Äôd like to leave behind before sleeping?"
    },
    {
        "title": "üåô Just check in",
        "body": "What‚Äôs sitting with you right now?"
    }
]


def send_night_reflection_notification(fcm_token: str):
    try:
        today = datetime.now(timezone.utc).date()
        index = today.toordinal() % len(NIGHT_PROMPTS)
        prompt = NIGHT_PROMPTS[index]

        message = messaging.Message(
            notification=messaging.Notification(
                title=prompt["title"],
                body=prompt["body"]
            ),
            data={
                "type": "night_reflection",
                "screen": "chat",
                "date": today.isoformat()
            },
            token=fcm_token,
        )

        return messaging.send(message)

    except Exception as e:
        print(f"‚ùå Error sending night notification: {e}")
        return None


# ============================================================
# üéØ STORE USER SELECTED INTENTION
# ============================================================

@bp.route("/set_intention", methods=["POST"])
def set_intention():
    try:
        data = request.get_json()
        user_id = data.get("user_id")
        intention = data.get("intention")

        if not user_id or not intention:
            return jsonify({"error": "Missing user_id or intention"}), 400

        today = datetime.now(timezone.utc).date().isoformat()

        db.collection("users").document(user_id).set(
            {
                "today_intention": intention,
                "intention_date": today,
                "intention_set_at": datetime.now(timezone.utc),
            },
            merge=True
        )

        db.collection("users") \
            .document(user_id) \
            .collection("mergedMessages") \
            .add({
                "type": "intention",
                "message": f"üéØ Today‚Äôs intention: {intention}",
                "timestamp": datetime.now(timezone.utc),
                "from": "system",
                "is_notification": False,
                "date": today,
            })

        return jsonify({"status": "success"})

    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to store intention"}), 500


# ============================================================
# üëã OPTIONAL WELCOME NOTIFICATION
# ============================================================

def send_welcome_notification(token):
    try:
        message = messaging.Message(
            notification=messaging.Notification(
                title="Welcome to RETVRN",
                body="What‚Äôs on your mind right now? Write or speak freely."
            ),
            token=token,
        )
        return messaging.send(message)
    except Exception as e:
        print(f"‚ùå Welcome notification error: {e}")
        return None
rewards.py:
import json
from datetime import datetime, timedelta
from tasks import USER_PROGRESS_FILE

XP_REWARDS = {
    "level_up": 10,
    "daily_streak_3": 15,
    "daily_streak_7": 30,
    "daily_streak_14": 50,
    "daily_streak_30": 100,
    "message_streak_5": 20
}

BADGES = {
    "level_up": "üå± Level Up",
    "daily_streak_3": "üî• 3-Day Streak",
    "daily_streak_7": "üåü Weekly Explorer",
    "daily_streak_14": "üåô Fortnight Champion",
    "daily_streak_30": "üåï Monthly Master",
    "message_streak_5": "üí¨ Chatterbox"
}

def get_user_progress(user_id):
    try:
        with open(USER_PROGRESS_FILE, "r") as f:
            all_progress = json.load(f)
        return all_progress.get(user_id, {
            "xp": 0,
            "level": 1,
            "last_level": 1,
            "streak": 0,
            "last_active_date": None,
            "message_count": 0,
            "badges": []
        })
    except Exception:
        return {
            "xp": 0,
            "level": 1,
            "last_level": 1,
            "streak": 0,
            "last_active_date": None,
            "message_count": 0,
            "badges": []
        }

def save_user_progress(user_id, progress):
    try:
        with open(USER_PROGRESS_FILE, "r") as f:
            all_progress = json.load(f)
        all_progress[user_id] = progress
        with open(USER_PROGRESS_FILE, "w") as f:
            json.dump(all_progress, f, indent=2)
    except Exception as e:
        print("Error saving user progress:", e)

def update_streak(user_id):
    progress = get_user_progress(user_id)
    today = datetime.utcnow().date().isoformat()
    last_active = progress.get("last_active_date")
    
    if last_active == today:
        # Already updated today; return current streak
        return progress["streak"]
    
    if last_active and (datetime.fromisoformat(last_active).date() + timedelta(days=1)) == datetime.utcnow().date():
        # Continue the streak
        progress["streak"] += 1
    else:
        # Reset streak
        progress["streak"] = 1
    
    progress["last_active_date"] = today
    save_user_progress(user_id, progress)
    return progress["streak"]

def check_streak_rewards(user_id, streak):
    progress = get_user_progress(user_id)
    rewards = []
    
    if streak == 3 and "daily_streak_3" not in progress["badges"]:
        progress["xp"] += XP_REWARDS["daily_streak_3"]
        progress["badges"].append("daily_streak_3")
        rewards.append(BADGES["daily_streak_3"])
    
    if streak == 7 and "daily_streak_7" not in progress["badges"]:
        progress["xp"] += XP_REWARDS["daily_streak_7"]
        progress["badges"].append("daily_streak_7")
        rewards.append(BADGES["daily_streak_7"])
    
    if streak == 14 and "daily_streak_14" not in progress["badges"]:
        progress["xp"] += XP_REWARDS["daily_streak_14"]
        progress["badges"].append("daily_streak_14")
        rewards.append(BADGES["daily_streak_14"])
    
    if streak == 30 and "daily_streak_30" not in progress["badges"]:
        progress["xp"] += XP_REWARDS["daily_streak_30"]
        progress["badges"].append("daily_streak_30")
        rewards.append(BADGES["daily_streak_30"])
    
    if rewards:
        save_user_progress(user_id, progress)
    
    return rewards

def check_message_rewards(user_id):
    progress = get_user_progress(user_id)
    progress["message_count"] += 1
    rewards = []
    
    if progress["message_count"] >= 5 and "message_streak_5" not in progress["badges"]:
        progress["xp"] += XP_REWARDS["message_streak_5"]
        progress["badges"].append("message_streak_5")
        rewards.append(BADGES["message_streak_5"])
    
    save_user_progress(user_id, progress)
    return rewards

routes.py:

from __init__ import create_app  # relative import from _init_.py in same folder

app = create_app()

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

scheduling.py:

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from datetime import datetime, timezone, timedelta
import os

from firebase_utils import db
from notifications import (
    send_morning_intention_notification,
    send_night_reflection_notification
)

# --------------------------------------------------
# ENV CONFIG (USER LOCAL TIME)
# --------------------------------------------------
MORNING_TIME = os.getenv("MORNING_TIME", "09:00")  # HH:MM
MORNING_GRACE_MINUTES = int(os.getenv("MORNING_GRACE_MINUTES", "10"))

NIGHT_TIME = os.getenv("NIGHT_TIME", "21:30")  # HH:MM
NIGHT_GRACE_MINUTES = int(os.getenv("NIGHT_GRACE_MINUTES", "15"))

scheduler = BackgroundScheduler(daemon=True)

# --------------------------------------------------
# HELPERS
# --------------------------------------------------
def minutes_since_midnight(dt):
    return dt.hour * 60 + dt.minute


def get_user_now(now_utc, offset_minutes):
    """
    Convert UTC -> user local time using offset minutes.
    """
    return now_utc + timedelta(minutes=offset_minutes)


# --------------------------------------------------
# MORNING SCHEDULER
# --------------------------------------------------
def schedule_morning_intention():
    JOB_ID = "morning_intention_windowed"

    def notify_users():
        now_utc = datetime.now(timezone.utc)
        users = db.collection("users").stream()

        for user_doc in users:
            user = user_doc.to_dict()
            user_id = user_doc.id

            fcm_token = user.get("fcm_token")
            offset = user.get("timezone_offset_minutes")

            if not fcm_token or offset is None:
                continue

            # --- user local time ---
            user_now = get_user_now(now_utc, offset)
            user_today = user_now.date().isoformat()

            # --- already sent today (user-local) ---
            if user.get("last_morning_notification_date") == user_today:
                continue

            # --- target window ---
            h, m = map(int, MORNING_TIME.split(":"))
            now_minutes = minutes_since_midnight(user_now)
            target_minutes = h * 60 + m

            if target_minutes <= now_minutes <= target_minutes + MORNING_GRACE_MINUTES:
                send_morning_intention_notification(fcm_token)

                db.collection("users").document(user_id).set(
                    {
                        "last_morning_notification_date": user_today,
                        "last_morning_notification_at": now_utc,
                    },
                    merge=True,
                )

    scheduler.add_job(
        notify_users,
        CronTrigger(minute="*", timezone="UTC"),
        id=JOB_ID,
        replace_existing=True,
    )


# --------------------------------------------------
# NIGHT SCHEDULER
# --------------------------------------------------
def schedule_night_reflection():
    JOB_ID = "night_reflection_windowed"

    def notify_users():
        now_utc = datetime.now(timezone.utc)
        users = db.collection("users").stream()

        for user_doc in users:
            user = user_doc.to_dict()
            user_id = user_doc.id

            fcm_token = user.get("fcm_token")
            offset = user.get("timezone_offset_minutes")

            if not fcm_token or offset is None:
                continue

            # --- user local time ---
            user_now = get_user_now(now_utc, offset)
            user_today = user_now.date().isoformat()

            # --- already sent today (user-local) ---
            if user.get("last_night_notification_date") == user_today:
                continue

            # --- target window ---
            h, m = map(int, NIGHT_TIME.split(":"))
            now_minutes = minutes_since_midnight(user_now)
            target_minutes = h * 60 + m

            if target_minutes <= now_minutes <= target_minutes + NIGHT_GRACE_MINUTES:
                send_night_reflection_notification(fcm_token)

                db.collection("users").document(user_id).set(
                    {
                        "last_night_notification_date": user_today,
                        "last_night_notification_at": now_utc,
                    },
                    merge=True,
                )

    scheduler.add_job(
        notify_users,
        CronTrigger(minute="*", timezone="UTC"),
        id=JOB_ID,
        replace_existing=True,
    )


# --------------------------------------------------
# START ALL SCHEDULERS
# --------------------------------------------------
def start_schedulers():
    schedule_morning_intention()
    schedule_night_reflection()

    if not scheduler.running:
        scheduler.start()

    print("üåÖüåô Morning & Night schedulers started")

spiral_dynamics.py:

import os
import json
import re
from openai import OpenAI

# Constants and config
STAGES = ["Beige", "Purple", "Red", "Blue", "Orange", "Green", "Yellow", "Turquoise"]

STAGE_GAMIFIED_META = {
    "Beige": {"emoji": "üü§", "name": "Beige", "reward": "Basic awareness"},
    "Purple": {"emoji": "üü£", "name": "Purple", "reward": "Group belonging"},
    "Red": {"emoji": "üî¥", "name": "Red", "reward": "Power attainment"},
    "Blue": {"emoji": "üîµ", "name": "Blue", "reward": "Order and stability"},
    "Orange": {"emoji": "üü†", "name": "Orange", "reward": "Achievement"},
    "Green": {"emoji": "üü¢", "name": "Green", "reward": "Community and connection"},
    "Yellow": {"emoji": "üü°", "name": "Yellow", "reward": "Integration"},
    "Turquoise": {"emoji": "üî∑", "name": "Turquoise", "reward": "Global consciousness"},
}

# Read OpenAI key from environment
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("‚ùå Missing OPENAI_API_KEY environment variable")

client = OpenAI(api_key=OPENAI_API_KEY)


# ----------------------------
# Intent detection (deterministic)

def detect_intent(entry: str) -> str:
    """
    Return:
      - 'ask_stage' if the message is the user asking about THEIR OWN Spiral Dynamics level
      - 'spiral'    if message is reflective/emotional/values-driven
      - 'chat'      otherwise (normal conversation)

    For existing users who already have a stage:
    - The endpoints decide what to do.
    - This function ONLY classifies the message itself.
    """
    if not entry or not entry.strip():
        return "chat"

    text = entry.strip()
    lower = f" {text.lower()} "  # padding for simple word-boundary checks

    # -------------------------
    # 1Ô∏è‚É£ Fast heuristic: user asking "what is MY stage/level/colour?"
    # -------------------------
    stage_keywords = [
        "spiral dynamics", "spiral dynamic", "spiral level", "spiral stage",
        "which stage am i", "what is my stage", "what's my stage",
        "what is my level", "what's my level",
        "which colour am i", "which color am i",
        "which spiral colour", "which spiral color",
        "what colour am i", "what color am i",
        "what stage am i in", "which stage in spiral",
        "my spiral stage", "my spiral level",
        "which stage do i belong", "which stage do i fit",
        "where do i fit in spiral", "where do i fall in spiral",
    ]

    # User is clearly talking about Spiral Dynamics + themselves
    if any(kw in lower for kw in stage_keywords):
        if any(p in lower for p in [" my ", " me ", " i ", " i'm ", " im ", " am i "]):
            return "ask_stage"

    # Very short messages like "my level?" / "which stage?"
    short = len(text.split()) <= 6
    short_markers = ["my level", "my stage", "which stage", "which level"]
    if short and any(kw in lower for kw in short_markers):
        return "ask_stage"

    # -------------------------
    # 2Ô∏è‚É£ Original LLM-based spiral vs chat classification
    # -------------------------
    prompt = (
        "You are a strict intent classifier. If the message expresses emotions, life struggle, "
        "deep reflection, longing for change, or values-based thought, reply exactly with the single word: spiral\n"
        "Otherwise reply exactly with the single word: chat\n\n"
        f"Message: \"{entry}\""
    )
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=8,
        )
        content = resp.choices[0].message.content.strip().lower()
        return "spiral" if content.startswith("spiral") else "chat"
    except Exception as e:
        # on failure, default to chat to avoid over-triggering spiral logic
        print("detect_intent failed:", e)
        return "chat"


# ----------------------------
# Stage classifier (robust, returns mind_mirror + mood)
# ----------------------------
def classify_stage(entry: str, context: str = None) -> dict:
    """
    Return:
      - stage (primary stage name string)
      - secondary (secondary stage or None)
      - confidence (float 0.0-1.0)
      - reason (short string)
      - mind_mirror (short reflective sentence or None)
      - mood (single word mood label or None)
    """
    ctx_part = f"\nContext:\n{context}\n" if context else ""
    prompt = (
        f"Analyze the following user text using Spiral Dynamics stages: {', '.join(STAGES)}.\n\n"
        "Return a JSON object with keys exactly: primary_stage, secondary_stage, confidence (0-1), reason, "
        "mind_mirror (one reflective sentence, max 20 words), mood (single word like bored/sad/anxious/hopeful).\n\n"
        f"{ctx_part}\nInput: \"{entry}\""
    )

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=350,
        )
        raw = resp.choices[0].message.content.strip()
    except Exception as e:
        print("classify_stage AI call failed:", e)
        return {
            "stage": "Unknown",
            "secondary": None,
            "confidence": 0.0,
            "reason": "classification_failed",
            "mind_mirror": None,
            "mood": None,
        }

    # Try to parse JSON robustly
    parsed = None
    try:
        parsed = json.loads(raw)
    except Exception:
        m = re.search(r'(\{[\s\S]*\})', raw)
        if m:
            try:
                parsed = json.loads(m.group(1))
            except Exception:
                parsed = None

    # Fallback to simple line-parsing
    if not parsed:
        parsed = {}
        for line in raw.splitlines():
            if ":" in line:
                k, v = line.split(":", 1)
                parsed[k.strip().lower()] = v.strip()

    def _get(d, *keys):
        for k in keys:
            if k in d and d[k] not in (None, ""):
                return d[k]
        return None

    primary = _get(parsed, "primary_stage", "primary", "stage")
    secondary = _get(parsed, "secondary_stage", "secondary")
    reason = _get(parsed, "reason", "explanation")
    mind_mirror = _get(parsed, "mind_mirror", "mindmirror", "mirror", "reflection")
    mood = _get(parsed, "mood", "emotion", "feeling")

    # Normalize confidence
    confidence = 0.0
    raw_conf = _get(parsed, "confidence", "conf")
    if raw_conf is not None:
        try:
            confidence = float(str(raw_conf).strip())
            if confidence > 1:
                confidence = confidence / 100.0
        except Exception:
            confidence = 0.0

    if not primary:
        primary = "Unknown"

    return {
        "stage": primary,
        "secondary": secondary,
        "confidence": confidence,
        "reason": reason,
        "mind_mirror": mind_mirror,
        "mood": mood,
    }


# ----------------------------
# Evolution check
# ----------------------------
def check_evolution(last_stage: str, current_result: dict) -> str:
    if not last_stage:
        return None
    current_stage = current_result.get("stage", "Unknown")
    try:
        last_idx = STAGES.index(last_stage)
        current_idx = STAGES.index(current_stage)
        confidence = current_result.get("confidence", 0)
        if current_idx > last_idx and confidence >= 0.6:
            return f"üå± Level Up! You're showing strong {current_stage} tendencies!"
        elif current_idx > last_idx:
            return f"üåÄ Exploring {current_stage}, with elements of {last_stage}."
    except ValueError:
        pass
    return None


# ----------------------------
# Reflective question generator
# ----------------------------
def generate_reflective_question(entry: str, reply_to: str = None, context: str = None) -> str:
    ctx = ""
    if reply_to:
        ctx += f"\nReplying to: \"{reply_to}\""
    if context:
        ctx += f"\nContext: {context}"
    prompt = (
        f"You are a Spiral Dynamics mentor. Based on the user's thoughts{ctx}, "
        "ask ONE deep, emotionally resonant question (max 15 words). Only output the question.\n\n"
        f"User message: \"{entry}\""
    )
    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.85,
            max_tokens=60,
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print("generate_reflective_question failed:", e)
        return "What would that change look like for you?"


# ----------------------------
# Gamified prompt generator
# ----------------------------
def generate_gamified_prompt(stage: str, entry: str, evolution: bool = False) -> dict:
    stage_meta = STAGE_GAMIFIED_META.get(stage, STAGE_GAMIFIED_META["Green"])
    prompt_template = (
        f"Create a gamified interaction for a user at the {stage} stage of Spiral Dynamics. "
        f"The user just shared: '{entry}'\n\n"
        "Return a JSON object with keys: question, prompt, reward.\n"
        " - question: 5-10 word reflective question\n"
        " - prompt: concrete action (max 15 words)\n"
        " - reward: short reward description\n"
    )
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt_template}],
            temperature=0.7,
            max_tokens=200,
        )
        raw = resp.choices[0].message.content.strip()
        try:
            content = json.loads(raw)
        except Exception:
            m = re.search(r'(\{[\s\S]*\})', raw)
            content = json.loads(m.group(1)) if m else {}
        return {
            "gamified_question": f"{stage_meta['emoji']} {stage_meta['name']}\nüéØ {content.get('question','')}",
            "gamified_prompt": f"üí° {content.get('prompt','')}",
            "reward": content.get('reward') if evolution else stage_meta["reward"]
        }
    except Exception as e:
        print("generate_gamified_prompt failed:", e)
        return {
            "gamified_question": f"{stage_meta['emoji']} {stage_meta['name']}\nüéØ What about this resonates most with you?",
            "gamified_prompt": "üí° Reflect on how this shows up in your daily life",
            "reward": stage_meta["reward"]
        }


# ----------------------------
# Mission feedback line (stage + mood + completion)
# ----------------------------
def build_mission_feedback_line(stage: str, mood: str, completion: str = "full") -> str:
    """
    Small, friendly line after a mission-related spiral reply.
    Uses:
      - stage: Spiral Dynamics stage (string)
      - mood:  simple mood label from classifier (string or None)
      - completion: 'full' / 'partial' / 'none' (currently we use 'full')
    """
    if not completion or completion == "none":
        return ""

    stage = (stage or "Unknown").strip()
    mood_l = (mood or "").strip().lower()

    # 1) Base line depending on completion
    if completion == "partial":
        line = "I‚Äôm really glad you at least touched this mission today. That effort still matters."
    else:  # full
        line = "I‚Äôm really glad you showed up for yourself with this mission today."

    # 2) Mood-sensitive soft addition
    heavy_moods = {"sad", "low", "tired", "anxious", "overwhelmed", "drained", "stressed"}
    light_moods = {"calm", "relieved", "okay", "peaceful", "light"}
    proud_moods = {"proud", "hopeful", "motivated", "excited", "inspired"}

    extra = ""

    if mood_l in heavy_moods:
        extra = " It‚Äôs okay if it still feels a bit heavy ‚Äî you‚Äôre allowed to go slowly."
    elif mood_l in light_moods:
        extra = " Notice how your system feels after doing this, even in small ways."
    elif mood_l in proud_moods:
        extra = " Let that small sense of progress sink in for a moment."

    # 3) Stage-flavoured tiny hint (very soft, no pressure)
    stage_l = stage.lower()
    stage_hint = ""

    if stage_l == "green":
        stage_hint = " This kind of gentle action really fits your care-for-people side."
    elif stage_l == "orange":
        stage_hint = " These small experiments quietly support your longer-term goals."
    elif stage_l == "blue":
        stage_hint = " Keeping small promises like this slowly builds inner stability."
    elif stage_l == "yellow":
        stage_hint = " Noticing how this mission connects different parts of your life can be powerful."
    elif stage_l == "purple":
        stage_hint = " Any movement you make here also supports your sense of belonging and safety."
    # Other stages ‚Üí no extra hint, keep it simple

    return (line + extra + stage_hint).strip()

tts.py:

import os
from openai import OpenAI

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("Missing OPENAI_API_KEY for TTS")

_client = OpenAI(api_key=OPENAI_API_KEY)

def stream_tts_from_openai(text: str):
    """
    Generator: OpenAI TTS se PCM/MP3 bytes stream karta hai.
    Flask Response(generator, mimetype='audio/mpeg') ke saath use karo.
    """
    # MP3 chahiye to response_format='mp3' ya fast streaming ke liye 'pcm'
    with _client.audio.speech.with_streaming_response.create(
        model="gpt-4o-mini-tts",   # ya tumhara jo TTS model ho
        voice="alloy",             # ya koi bhi supported voice
        input=text,
        response_format="mp3",     # ‚ö†Ô∏è Yahi kaafi important change hai
    ) as response:
        for chunk in response.iter_bytes(chunk_size=4096):
            if not chunk:
                continue
            yield chunk

tasks.py:

import os
import json
from datetime import datetime, timedelta
import random

SPIRAL_TASKS = [
        "Recall a time when your only focus was to make it through the day. What mattered most in that moment?",
    "When your basic needs aren't met, how does your mindset change?",
    "Think of a moment when safety or food felt uncertain. How did you respond?",
    "Are there superstitions or rituals you follow without fully knowing why? What do they mean to you?",
    "Describe a tradition your family follows that makes you feel rooted. Why is it important?",
    "How do you stay connected to your ancestry, roots, or community?",
    "Have you ever acted on impulse just because it felt right in the moment? What happened?",
    "Describe a time when you took control of a situation without waiting for permission. Why did you do it?",
    "When do you feel most powerful or in control?",
    "How do you deal with people who challenge your authority or choices?",
    "What moral code or set of values do you try to live by? How did you come to believe in it?",
    "Think of a time you followed a rule that you didn't fully agree with. Why did you do it?",
    "What does loyalty mean to you, and who deserves it?",
    "When someone breaks a rule or law, what's your first reaction ‚Äî curiosity, anger, or something else?",
    "What does success mean to you beyond financial gain? How do you measure your progress?",
    "Have you ever pushed yourself too hard to prove something to others? Why did it matter so much?",
    "How do you react when someone limits your freedom or questions your ability?",
    "What's a personal goal that you're proud of achieving? What drove you to it?",
    "Is competition a healthy part of life for you? Why or why not?",
    "When was the last time you deeply empathized with someone you disagreed with? What did you learn?",
    "How do you decide when to speak up for others versus stay quiet for harmony?",
    "Think of a group or cause you care about. Why does it matter to you?",
    "Do you believe in absolute truths, or is everything relative to context?",
    "How do you handle tension when people don't feel heard?",
    "Do you ever hide your opinions to keep peace? How does that affect you?",
    "Have you ever realized both sides of an argument were valid? How did you respond?",
    "Do you ever switch perspectives just to understand something more deeply?",
    "Describe a moment when you helped two opposing views find common ground.",
    "What's more important to you ‚Äî being right, or being helpful in a larger system?",
    "How do you handle paradoxes or contradictions in life?",
    "Have you ever felt part of something much larger than yourself? What was that experience like?",
    "How do you define harmony ‚Äî is it internal, collective, spiritual?",
    "When do you feel most connected to all forms of life or nature?",
    "Describe a time you made a decision that honored both logic and intuition.",
    "What does planetary well-being mean to you?",
    "Have your values changed over the years? What sparked the shift?",
    "When do you feel most authentic ‚Äî when leading, listening, creating, or something else?",
    "What role does tradition play in your life today?",
    "When you disagree with someone close to you, do you debate, reflect, or avoid?",
    "What part of your identity do you feel is constantly evolving?",
    "Do you feel you have a personal truth? How did you discover it?",
    "How do you know when it's time to move on from a belief?",
    "If someone asked why you do what you do, how would you explain your purpose?",
    "When you're uncertain, what guides your choices ‚Äî logic, values, instinct, or something else?",
    "What does freedom mean to you right now?",
    "Have you ever tried to influence others' beliefs? Why or why not?",
    "Do you often seek answers, or feel okay with not knowing?",
    "Do you adapt your behavior depending on the environment or people around you?",
    "When was the last time you questioned your worldview?",
    "If everyone followed your philosophy of life, what kind of world would we have?",
    "Do you trust people easily? Why or why not?",
    "What do you feel you've outgrown, mentally or emotionally?",
    "Do you often feel pulled in different directions ‚Äî between structure, freedom, purpose, and peace?",
    "Do you value clarity or complexity more when making sense of life?",
    "What type of change feels threatening to you, and why?",
    "What type of change feels exciting to you, and why?",
    "How do you decide what's worth standing up for?",
    "What kind of legacy feels meaningful to leave behind?",
    "What does growth mean to you?",
    "If you could fully express your truth without fear, what would you say?"
]

DAILY_TASKS_FILE = "daily_tasks.json"
COMPLETED_TASKS_FILE = "completed_tasks.json"
USER_PROGRESS_FILE = "user_progress.json"

def init_task_files():
    """Initialize required JSON files if they do not already exist."""
    for file_path in [COMPLETED_TASKS_FILE, DAILY_TASKS_FILE, USER_PROGRESS_FILE]:
        if not os.path.exists(file_path):
            with open(file_path, "w") as f:
                if file_path == USER_PROGRESS_FILE:
                    json.dump({}, f)
                else:
                    json.dump([], f)

def generate_daily_task():
    """Generate or retrieve today's shared daily task."""
    today = datetime.utcnow().date().isoformat()
    try:
        with open(DAILY_TASKS_FILE, "r") as f:
            tasks = json.load(f)
    except Exception:
        tasks = []

    # Check if a task already exists for today
    existing_task = next((t for t in tasks if t.get("date") == today), None)
    if existing_task:
        return existing_task

    # If none exists, choose a random new task and save it
    task_content = random.choice(SPIRAL_TASKS)
    task_data = {
        "user_id": "all",  # Indicates this is the shared daily task
        "task": task_content,
        "date": today,
        "completed": False,
        "timestamp": datetime.utcnow().isoformat()
    }
    tasks.append(task_data)
    try:
        with open(DAILY_TASKS_FILE, "w") as f:
            json.dump(tasks, f, indent=2)
    except Exception as e:
        print("Error saving daily task:", e)
    return task_data

def save_completed_task(user_id, task_data):
    """
    Save the completion status of a daily task for a given user.
    """
    try:
        with open(COMPLETED_TASKS_FILE, "r") as f:
            tasks = json.load(f)
    except Exception:
        tasks = []

    completed_entry = {
        "user_id": user_id,
        "task": task_data.get("task"),
        "stage": task_data.get("stage"),
        "date": datetime.utcnow().date().isoformat(),
        "completed": True,
        "timestamp": datetime.utcnow().isoformat(),
        "completion_timestamp": datetime.utcnow().isoformat()
    }
    tasks.append(completed_entry)

    try:
        with open(COMPLETED_TASKS_FILE, "w") as f:
            json.dump(tasks, f, indent=2)
    except Exception as e:
        print("Error saving completed task:", e)

def get_user_tasks(user_id, file_path):
    try:
        with open(file_path, "r") as f:
            tasks = json.load(f)
        return [t for t in tasks if t.get("user_id") == user_id]
    except:
        return []

def get_recent_tasks(user_id, n_days=30):
    user_tasks = get_user_tasks(user_id, DAILY_TASKS_FILE)
    cutoff = datetime.utcnow().date() - timedelta(days=n_days)
    return [t['task'] for t in user_tasks if datetime.fromisoformat(t['date']).date() >= cutoff]

def generate_daily_task_content(user_id, recent_tasks):
    available = [task for task in SPIRAL_TASKS if task not in recent_tasks]
    if not available:
        available = SPIRAL_TASKS[:]
    return random.choice(available)

def save_daily_task(task_data):
    try:
        with open(DAILY_TASKS_FILE, "r") as f:
            tasks = json.load(f)
        tasks = [t for t in tasks if not (
            t.get("user_id") == task_data.get("user_id") and 
            t.get("date") == task_data.get("date")
        )]
        tasks.append(task_data)
        with open(DAILY_TASKS_FILE, "w") as f:
            json.dump(tasks, f, indent=2)
    except Exception as e:
        print("Error saving daily task:", e)