spiral_dynamics.py:

import os
import json
from openai import OpenAI
# from config import A4F_API_KEY

# Constants and config
STAGES = ["Beige", "Purple", "Red", "Blue", "Orange", "Green", "Yellow", "Turquoise"]

STAGE_GAMIFIED_META = {
    "Beige": {"emoji": "ğŸŸ¤", "name": "Beige", "reward": "Basic awareness"},
    "Purple": {"emoji": "ğŸŸ£", "name": "Purple", "reward": "Group belonging"},
    "Red": {"emoji": "ğŸ”´", "name": "Red", "reward": "Power attainment"},
    "Blue": {"emoji": "ğŸ”µ", "name": "Blue", "reward": "Order and stability"},
    "Orange": {"emoji": "ğŸŸ ", "name": "Orange", "reward": "Achievement"},
    "Green": {"emoji": "ğŸŸ¢", "name": "Green", "reward": "Community and connection"},
    "Yellow": {"emoji": "ğŸŸ¡", "name": "Yellow", "reward": "Integration"},
    "Turquoise": {"emoji": "ğŸ”·", "name": "Turquoise", "reward": "Global consciousness"},
}


# âœ… Safely read key from Render environment
# A4F_API_KEY = os.getenv("A4F_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")


if not OPENAI_API_KEY:
    raise ValueError("âŒ Missing OPENAI_API_KEY environment variable")

# if not A4F_API_KEY:
#     raise ValueError("âŒ Missing A4F_API_KEY environment variable â€” check Render settings.")
# Initialize OpenAI client
# client = OpenAI(api_key=A4F_API_KEY, base_url="https://api.a4f.co/v1")
client = OpenAI(api_key=OPENAI_API_KEY)

def detect_intent(entry: str) -> str:
    prompt = (
        "You are a Spiral Dynamics gatekeeper.\n"
        "Determine if this journal entry reflects emotional expression, life struggle, desire for change, personal values, reflection, or self-awareness.\n"
        "If yes, return 'spiral'. If it's only surface-level chat, jokes, or small talk, return 'chat'.\n"
        f"Entry: \"{entry}\""
    )
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": prompt}],
        temperature=0,   
    )
    content = response.choices[0].message.content.lower()
    return "spiral" if "spiral" in content else "chat"

def classify_stage(entry: str) -> dict:
    prompt = (
        f"Analyze this user input and classify its dominant Spiral Dynamics stage from: {', '.join(STAGES)}.\n"
        "Respond with JSON containing:\n"
        "- 'primary_stage': The most dominant stage\n"
        "- 'secondary_stage': Second most present stage (if any)\n"
        "- 'confidence': Your confidence in primary stage (0-1)\n"
        "- 'reason': Brief explanation of your choice\n\n"
        f"Input: \"{entry}\""
    )
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3,
        response_format={"type": "json_object"}
    )
    try:
        result = json.loads(response.choices[0].message.content)
        return {
            "stage": result.get("primary_stage", "Unknown"),
            "secondary": result.get("secondary_stage"),
            "confidence": float(result.get("confidence", 0)),
            "reason": result.get("reason", "")
        }
    except Exception:
        fallback = client.chat.completions.create(
            model="gpt-4.1",
            messages=[{"role": "user", "content": f"Classify this into one stage from {', '.join(STAGES)}: {entry}"}],
            temperature=0
        )
        return {
            "stage": fallback.choices[0].message.content.strip(),
            "secondary": None,
            "confidence": 1.0,
            "reason": ""
        }

def check_evolution(last_stage: str, current_result: dict) -> str:
    if not last_stage:
        return None
    current_stage = current_result.get("stage", "Unknown")
    try:
        last_idx = STAGES.index(last_stage)
        current_idx = STAGES.index(current_stage)
        confidence = current_result.get("confidence", 0)
        if current_idx > last_idx and confidence >= 0.6:
            return f"ğŸŒ± Level Up! You're showing strong {current_stage} tendencies!"
        elif current_idx > last_idx:
            return f"ğŸŒ€ Exploring {current_stage}, with elements of {last_stage}."
    except ValueError:
        pass
    return None

def generate_reflective_question(entry: str, reply_to: str = None) -> str:
    context = f"\nReplying to: \"{reply_to}\"" if reply_to else ""
    prompt = (
        f"You are a Spiral Dynamics mentor. Based on the user's thoughts{context}, "
        "ask one deep, emotionally resonant question (max 15 words). Just ask the question.\n\n"
        f"User message: \"{entry}\""
    )
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.85
    )
    return response.choices[0].message.content.strip()

def generate_gamified_prompt(stage: str, entry: str, evolution: bool = False) -> dict:
    stage_meta = STAGE_GAMIFIED_META.get(stage, STAGE_GAMIFIED_META["Green"])
    prompt_template = (
        f"Create a gamified interaction for a user at the {stage} stage of Spiral Dynamics. "
        f"The user just shared: '{entry}'\n\n"
        "Provide:\n"
        "1. A VERY short reflective question (5-10 words) to deepen their awareness\n"
        "2. A concrete action prompt (max 15 words) aligned with their stage\n"
        "3. A stage-appropriate reward description\n"
        "Format as JSON with keys: question, prompt, reward"
    )
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[{"role": "user", "content": prompt_template}],
        temperature=0.7,
        response_format={"type": "json_object"}
    )
    try:
        content = json.loads(response.choices[0].message.content)
        return {
            "gamified_question": f"{stage_meta['emoji']} {stage_meta['name']}\nğŸ¯ {content.get('question','')}",
            "gamified_prompt": f"ğŸ’¡ {content.get('prompt','')}",
            "reward": content.get('reward') if evolution else stage_meta["reward"]
        }
    except Exception:
        return {
            "gamified_question": f"{stage_meta['emoji']} {stage_meta['name']}\nğŸ¯ What about this resonates most with you?",
            "gamified_prompt": "ğŸ’¡ Reflect on how this shows up in your daily life",
            "reward": stage_meta["reward"]
        }
routes.py:

from flask import Blueprint, request, jsonify
import json
import os
import traceback
from datetime import datetime
from collections import defaultdict
import requests

# Import your project modules - adjust import paths as necessary
from tasks import generate_daily_task, save_completed_task, get_user_tasks
from rewards import get_user_progress, save_user_progress, update_streak, check_streak_rewards, check_message_rewards
from spiral_dynamics import detect_intent, classify_stage, check_evolution, generate_reflective_question, generate_gamified_prompt
from firebase_utils import db
from notifications import send_welcome_notification
# from openai import OpenAI  # Your AI client instance configured elsewhere
from spiral_dynamics import client  # Your OpenAI client instance

bp = Blueprint('main', __name__)

AUDIO_FOLDER = "audios"
os.makedirs(AUDIO_FOLDER, exist_ok=True)

XP_REWARDS = {
    "level_up": 10,
    "daily_streak_3": 15,
    "daily_streak_7": 30,
    "daily_streak_14": 50,
    "daily_streak_30": 100,
    "message_streak": 20,
}

BADGES = {
    "level_up": "ğŸŒ± Level Up",
    "daily_streak_3": "ğŸ”¥ 3-Day Streak",
    "daily_streak_7": "ğŸŒŸ Weekly Explorer",
    "daily_streak_14": "ğŸŒ™ Fortnight Champion",
    "daily_streak_30": "ğŸŒ• Monthly Master",
    "message_streak": "ğŸ’¬ Chatterbox",
}

# âœ… New mission milestone rewards
MISSION_REWARDS = {
    1: {"xp": 20, "badge": "ğŸ¯ First Mission"},
    5: {"xp": 50, "badge": "ğŸ… Mission Explorer"},
    10: {"xp": 100, "badge": "ğŸš€ Mission Master"},
}


@bp.route('/')
def home():
    return "Backend is running"


@bp.route('/daily_task', methods=['GET'])
def daily_task():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        task = generate_daily_task()
        with open("completed_tasks.json") as f:
            completed = json.load(f)
        user_done = any(
            t for t in completed if t.get("user_id") == user_id and t.get("date") == task.get("date") and t.get("completed")
        )
        task["user_done"] = user_done
        return jsonify(task)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch daily task"}), 500


@bp.route('/complete_task', methods=['POST'])
def complete_task():
    data = request.json
    user_id = data.get("user_id")
    task_id = data.get("task_id")
    if not user_id or not task_id:
        return jsonify({"error": "Missing user_id or task_id"}), 400
    try:
        with open("daily_tasks.json") as f:
            tasks = json.load(f)
        task_to_complete = next((t for t in tasks if str(t.get("timestamp")) == task_id and t.get("user_id") == user_id), None)
        if not task_to_complete:
            return jsonify({"error": "Task not found"}), 404
        task_to_complete["completed"] = True
        task_to_complete["completion_timestamp"] = datetime.utcnow().isoformat()
        with open("daily_tasks.json", "w") as f:
            json.dump(tasks, f, indent=2)
        save_completed_task(user_id, task_to_complete)
        return jsonify({"message": "Task marked completed"})
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to complete task"}), 500


@bp.route('/task_history', methods=['GET'])
def task_history():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        tasks = get_user_tasks(user_id, "completed_tasks.json")
        return jsonify(tasks)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch task history"}), 500


@bp.route('/user_progress', methods=['GET'])
def user_progress():
    user_id = request.args.get("user_id")
    if not user_id:
        return jsonify({"error": "Missing user_id"}), 400
    try:
        progress = get_user_progress(user_id)
        return jsonify(progress)
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch user progress"}), 500


@bp.route('/merged', methods=['POST'])
def merged():
    try:
        data = request.json
        entry = data.get("text", "").strip()
        last_stage = data.get("last_stage", "").strip()
        reply_to = data.get("reply_to", "").strip()
        user_id = data.get("user_id")
        if not entry:
            return jsonify({"error": "Missing entry"}), 400

        streak = 0
        rewards = []
        message_rewards = []
        missions_completed = 0
        new_mission_reward = None

        if user_id:
            streak = update_streak(user_id)
            rewards = check_streak_rewards(user_id, streak)
            message_rewards = check_message_rewards(user_id)

        # âœ… Mission tracking if replying
        if reply_to and user_id:
            try:
                with open("daily_tasks.json") as f:
                    tasks = json.load(f)
                task_to_complete = next(
                    (t for t in tasks if t.get("task") == reply_to or str(t.get("timestamp")) == reply_to),
                    None
                )
                if task_to_complete:
                    save_completed_task(user_id, task_to_complete)

                    # Increment missions completed
                    progress = get_user_progress(user_id)
                    progress["missions_completed"] = progress.get("missions_completed", 0) + 1
                    missions_completed = progress["missions_completed"]

                    # Check mission milestone rewards
                    if missions_completed in MISSION_REWARDS:
                        reward = MISSION_REWARDS[missions_completed]
                        progress["xp"] += reward["xp"]
                        if reward["badge"] not in progress.get("badges", []):
                            progress["badges"].append(reward["badge"])
                        new_mission_reward = reward
                    save_user_progress(user_id, progress)
            except Exception as e:
                print("âš  Error marking growth prompt complete:", e)

        # Normal reflection/chat logic
        intent = detect_intent(entry)
        if intent == "chat":
            prompt_msg = entry
            if reply_to:
                prompt_msg = f"Previous: {reply_to}\nUser: {entry}"
            ai_resp = client.chat.completions.create(
                model='gpt-4.1',
                messages=[{"role": "user", "content": f"Be a kind friend and casually respond to:\n{prompt_msg}"}],
                temperature=0.7,
            ).choices[0].message.content.strip()
            return jsonify({
                "mode": "chat",
                "response": ai_resp,
                "streak": streak,
                "rewards": rewards,
                "message_rewards": message_rewards,
                "missions_completed": missions_completed,
                "new_mission_reward": new_mission_reward,
            })

        classification = classify_stage(entry)
        stage = classification.get("stage")
        evolution_msg = check_evolution(last_stage, classification)

        xp_gain = 0
        badges = []
        if user_id and evolution_msg:
            progress = get_user_progress(user_id)
            progress["xp"] += XP_REWARDS.get("level_up", 10)
            if "level_up" not in progress.get("badges", []):
                progress["badges"].append("level_up")
                badges.append("ğŸŒ± Level Up")
            save_user_progress(user_id, progress)
            xp_gain = XP_REWARDS.get("level_up", 10)

        gamified = generate_gamified_prompt(stage or last_stage, entry, evolution=bool(evolution_msg))
        question = generate_reflective_question(entry, reply_to)

        response = {
            "mode": "spiral",
            "stage": stage,
            "evolution": evolution_msg,
            "xp_gain": xp_gain,
            "badges": badges,
            "question": question,
            "gamified": gamified,
            "confidence": classification.get("confidence"),
            "reason": classification.get("reason"),
            "streak": streak,
            "rewards": rewards,
            "message_rewards": message_rewards,
            "missions_completed": missions_completed,
            "new_mission_reward": new_mission_reward,
        }
        if classification.get("confidence", 1) < 0.7 and classification.get("secondary"):
            response["note"] = f"Also detected: {classification['secondary']}"
        return jsonify(response)

    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to process reflection"}), 500


@bp.route('/reflect_transcription', methods=['POST'])
def reflect_transcription():
    try:
        if 'audio' not in request.files:
            return jsonify({"error": "Missing audio file"}), 400
        reply_to = request.form.get("reply_to", "")
        last_stage = request.form.get("last_stage", "")
        user_id = request.form.get("user_id", "")
        audio_file = request.files['audio']

        streak = 0
        rewards = []
        message_rewards = []
        missions_completed = 0
        new_mission_reward = None

        if user_id:
            streak = update_streak(user_id)
            rewards = check_streak_rewards(user_id, streak)
            message_rewards = check_message_rewards(user_id)

        # âœ… Mission tracking if replying (audio)
        if reply_to and user_id:
            try:
                with open("daily_tasks.json") as f:
                    tasks = json.load(f)
                task_to_complete = next(
                    (t for t in tasks if t.get("task") == reply_to or str(t.get("timestamp")) == reply_to),
                    None
                )
                if task_to_complete:
                    save_completed_task(user_id, task_to_complete)

                    # Increment missions completed
                    progress = get_user_progress(user_id)
                    progress["missions_completed"] = progress.get("missions_completed", 0) + 1
                    missions_completed = progress["missions_completed"]

                    # Check mission milestone rewards
                    if missions_completed in MISSION_REWARDS:
                        reward = MISSION_REWARDS[missions_completed]
                        progress["xp"] += reward["xp"]
                        if reward["badge"] not in progress.get("badges", []):
                            progress["badges"].append(reward["badge"])
                        new_mission_reward = reward
                    save_user_progress(user_id, progress)
            except Exception as e:
                print("âš  Error marking growth prompt complete (audio):", e)

        filename = f"{user_id or 'anon'}_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}.wav"
        os.makedirs("audios", exist_ok=True)
        path = os.path.join("audios", filename)
        audio_file.save(path)

        upload_resp = requests.post(
            "https://api.assemblyai.com/v2/upload",
            headers={"authorization": os.getenv("ASSEMBLYAI_API_KEY"), "content-type": "application/octet-stream"},
            data=open(path, "rb")
        )
        audio_url = upload_resp.json().get("upload_url")
        transcript_post = requests.post(
            "https://api.assemblyai.com/v2/transcript",
            headers={"authorization": os.getenv("ASSEMBLYAI_API_KEY")},
            json={"audio_url": audio_url, "speaker_labels": True}
        )
        transcript_id = transcript_post.json().get("id")

        while True:
            poll_resp = requests.get(
                f"https://api.assemblyai.com/v2/transcript/{transcript_id}",
                headers={"authorization": os.getenv("ASSEMBLYAI_API_KEY")},
            )
            poll_data = poll_resp.json()
            if poll_data.get("status") in ("completed", "error"):
                break

        if poll_data.get("status") == "error":
            return jsonify({"error": "Transcription failed"}), 500

        transcript_text = poll_data.get("text", "")
        utterances = poll_data.get("utterances", [])
        dialogue = "\n".join(f"Speaker {u['speaker']}: {u['text']}" for u in utterances)

        intent = detect_intent(transcript_text)
        # try:
        #     intent = detect_intent(transcript_text)
        # except openai.InternalServerError as e:
        #     app.logger.error(f"API error: {e}")
        #     return jsonify(error="Upstream AI service error, please try later"), 503
        if intent == "chat":
            ai_resp = client.chat.completions.create(
                model='gpt-4.1',
                messages=[{"role": "user", "content": f"Carefully respond to:\n{dialogue}"}],
                temperature=0.7,
            ).choices[0].message.content.strip()
            return jsonify({
                "mode": "chat",
                "response": ai_resp,
                "transcription": dialogue,
                "diarized": True,
                "streak": streak,
                "rewards": rewards,
                "message_rewards": message_rewards,
                "missions_completed": missions_completed,
                "new_mission_reward": new_mission_reward,
            })

        speaker_texts = defaultdict(str)
        for u in utterances:
            speaker_name = f"Speaker {u['speaker']}"
            speaker_texts[speaker_name] += u["text"] + " "

        speaker_stages = {}
        for speaker_name, text in speaker_texts.items():
            try:
                stage_info = classify_stage(text.strip())
                speaker_stages[speaker_name] = {"stage": stage_info["stage"], "text": text.strip()}
            except Exception as e:
                speaker_stages[speaker_name] = {"stage": "Unknown", "text": text.strip(), "error": str(e)}

        return jsonify({
            "mode": "spiral",
            "transcription": dialogue,
            "speaker_stages": speaker_stages,
            "diarized": True,
            "ask_speaker_pick": True,
            "streak": streak,
            "rewards": rewards,
            "message_rewards": message_rewards,
            "missions_completed": missions_completed,
            "new_mission_reward": new_mission_reward,
        })
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to process transcription"}), 500


@bp.route('/finalize_stage', methods=['POST'])
def finalize_stage():
    try:
        data = request.json
        speaker_id = data.get("speaker_id")
        speaker_stages = data.get("speaker_stages", {})
        last_stage = data.get("last_stage", "")
        reply_to = data.get("reply_to", "")
        user_id = data.get("user_id")

        if speaker_id not in speaker_stages:
            return jsonify({"error": "Speaker not found"}), 400

        speaker_info = speaker_stages[speaker_id]
        current_stage = speaker_info.get("stage", "Unknown")
        text = speaker_info.get("text", "")
        evolution_msg = check_evolution(last_stage, {"stage": current_stage})

        xp_gain = 0
        badges = []
        if user_id and evolution_msg:
            progress = get_user_progress(user_id)
            progress["xp"] += XP_REWARDS.get("level_up", 10)
            if "level_up" not in progress.get("badges", []):
                progress["badges"].append("level_up")
                badges.append("ğŸŒ± Level Up")
            save_user_progress(user_id, progress)
            xp_gain = XP_REWARDS.get("level_up", 10)

        gamified = generate_gamified_prompt(current_stage, text, evolution=bool(evolution_msg))
        question = generate_reflective_question(text, reply_to)

        return jsonify({
            "stage": current_stage,
            "question": question,
            "evolution": evolution_msg,
            "gamified": gamified,
            "xp_gain": xp_gain,
            "badges": badges,
        })
    except Exception:
        traceback.print_exc()
        return jsonify({"error": "Failed to finalize stage"}), 500
firebase_utils.py:
import firebase_admin
from firebase_admin import credentials, firestore
from config import FIREBASE_CONFIG

def init_firebase():
    """
    Initialize Firebase app and Firestore client.
    Returns the Firestore client instance or None if initialization fails.
    """
    try:
        # Initialize Firebase app with service account credentials
        cred = credentials.Certificate(FIREBASE_CONFIG)
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
        db = firestore.client()
        return db
    except Exception as e:
        print(f"Firebase initialization failed: {e}")
        return None

# Initialize Firestore client at module load
db = init_firebase()
__init__.py:

from flask import Flask
from flask_cors import CORS
from routes import bp  # Import the routes blueprint from routes.py

def create_app():
    """
    Application factory function to create and configure the Flask app.
    """
    app = Flask(__name__)  # Use __name__, not _name_
    app.config.from_object("config")  # Load config from config.py

    # Enable CORS to allow cross-origin requests
    CORS(app)

    # Register the routes blueprint
    app.register_blueprint(bp)

    # Start scheduling any background tasks like daily notifications
    from scheduling import schedule_daily_notifications
    schedule_daily_notifications()

    return app
